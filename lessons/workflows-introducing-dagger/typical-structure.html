<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/itu-bds-sdse/images/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/itu-bds-sdse/images/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/itu-bds-sdse/images/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="16x16" href="/itu-bds-sdse/images/favicon-16x16.png"/><link rel="icon" type="image/x-icon" href="/itu-bds-sdse/images/favicon.ico"/><title>Typical Dagger pipeline structure – Data Science in Production: MLOps and Software Engineering</title><meta name="description" content="Data Science in Production: MLOps and Software Engineering"/><meta name="keywords" content="your,Google,keywords,here"/><meta name="og:description" content="Data Science in Production: MLOps and Software Engineering"/><meta name="og:title" content="Typical Dagger pipeline structure – Data Science in Production: MLOps and Software Engineering"/><meta name="og:image" content="/itu-bds-sdse/images/social-share-cover.jpg"/><meta name="twitter:card" content="summary_large_image"/><meta name="next-head-count" content="14"/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/itu-bds-sdse/_next/static/css/aaf20f4dad916972.css" as="style"/><link rel="stylesheet" href="/itu-bds-sdse/_next/static/css/aaf20f4dad916972.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/itu-bds-sdse/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/itu-bds-sdse/_next/static/chunks/webpack-8116fd4d628798fe.js" defer=""></script><script src="/itu-bds-sdse/_next/static/chunks/framework-ecc4130bc7a58a64.js" defer=""></script><script src="/itu-bds-sdse/_next/static/chunks/main-348f16897b94a0d5.js" defer=""></script><script src="/itu-bds-sdse/_next/static/chunks/pages/_app-fa68bd1b4993f298.js" defer=""></script><script src="/itu-bds-sdse/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-c2cb604784d7e04f.js" defer=""></script><script src="/itu-bds-sdse/_next/static/aGU_TgP1G33XsxgAaS_TT/_buildManifest.js" defer=""></script><script src="/itu-bds-sdse/_next/static/aGU_TgP1G33XsxgAaS_TT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/itu-bds-sdse">Data Science in Production: MLOps and Software Engineering</a></h1><div class="navbar-info"></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><h2>Before we dive in</h2>
<p>We will be using Go for the example pipeline definition.</p>
<p>There are currently two ways to define a Dagger pipeline:</p>
<ol>
<li>Dagger functions, e.g. a function for each stage (build, test, deploy etc.).</li>
<li>A single Dagger pipeline function that contains all the stages.</li>
</ol>
<p>Dagger functions are relatively new and while they would in practice be more ideal to encapsulate and moduralize the pipeline, we will use the single Dagger pipeline function for the exercises. It is compact and simpler to maintain when workflows are small.</p>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

<h2>Typical Dagger pipeline structure</h2>
<ol>
<li>A pipeline in Go in its simplest form is a single file, e.g. <code>pipeline.go</code>.</li>
<li>The pipeline starts through the entry point function <code>main()</code>.</li>
<li>A Dagger client and background context is created. This is what orchestrates Docker under the hood and is responsible for building the execution graph.</li>
<li>Pipeline stages are defined. These consist of the code you want to run, e.g. shell commands.</li>
</ol>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

<p><img src="https://media1.tenor.com/m/4EYaYAMus0cAAAAd/michael-scott-the-office.gif" alt="Show me more"></p>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

<h2>How it works</h2>
<p><img src="../../images/lessons/dagger/dagger-oci.png" alt="Dagger how it works with OCI"></p>
<p><em>Source: <a href="https://archive.docs.dagger.io/0.9/sdk/go/">https://archive.docs.dagger.io/0.9/sdk/go/</a></em></p>
</br>

<p>When you run a Dagger pipeline using the Go SDK, the following happens:</p>
<ol>
<li><p><strong>Client initialization</strong>: Your Go program imports the Dagger Go SDK and creates a client connection by calling <code>dagger.Connect(ctx)</code>. The SDK handles all the GraphQL translation internally—you don&#39;t need to know GraphQL.</p>
</li>
<li><p><strong>Engine provisioning</strong>: The client either connects to an existing Dagger Engine or automatically provisions a new one on-the-fly. The Engine runs as an OCI-compatible (Open Container Initiative) container and acts as the runtime for your pipeline.</p>
</li>
<li><p><strong>Session creation</strong>: Once connected, your client opens a session with the Engine. Each session gets its own GraphQL server instance that manages the API requests for that session.</p>
</li>
<li><p><strong>Pipeline definition</strong>: Your Go code defines the pipeline operations (like creating containers, mounting directories, executing commands) using the SDK&#39;s type-safe API. These operations are translated into GraphQL queries that describe your workflow.</p>
</li>
<li><p><strong>Lazy evaluation</strong>: The Engine uses lazy evaluation—operations are only executed when their results are actually needed. For example, if you define a container build but never request its output, the build won&#39;t run. This allows the Engine to optimize away unnecessary work.</p>
</li>
<li><p><strong>DAG computation</strong>: When a result is requested (a &quot;leaf value&quot; like <code>stdout</code> or exported files), the Engine computes a Directed Acyclic Graph (DAG) of all operations needed to produce that result. This graph represents the execution plan.</p>
</li>
<li><p><strong>Concurrent execution</strong>: The Engine executes operations in the DAG concurrently wherever possible, maximizing parallelism and performance while respecting dependencies between operations.</p>
</li>
<li><p><strong>Result delivery</strong>: Once all required operations complete, the Engine returns the results to your Go program. These results can be used as inputs to subsequent pipeline stages or exported to your local filesystem.</p>
</li>
</ol>
</br>

<p><em>Source: <a href="https://docs.dagger.io/manuals/developer/architecture/">https://docs.dagger.io/manuals/developer/architecture/</a> and <a href="https://docs.dagger.io/api/internals/">https://docs.dagger.io/api/internals/</a></em></p>
</br>
</br>

<p>Ok.. Let&#39;s continue and start building a pipeline! <i class="fa-solid fa-rocket"></i></p>
</br>
</br>
</div><div class="lesson-links"><a href="/itu-bds-sdse/lessons/workflows-introducing-dagger/common-scenario-and-benefits" class="prev">← Previous</a><a href="/itu-bds-sdse/lessons/workflows-creating-and-running-a-dagger-pipeline/new-dagger-pipeline" class="next">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><footer class="footer"><ul class="socials"><li class="social"><a href="https://github.com/lasselundstenjensen/itu-bds-sdse"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/lasselundstenjensen"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Excercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{"title":"Typical Dagger pipeline structure"},"html":"\u003ch2\u003eBefore we dive in\u003c/h2\u003e\n\u003cp\u003eWe will be using Go for the example pipeline definition.\u003c/p\u003e\n\u003cp\u003eThere are currently two ways to define a Dagger pipeline:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDagger functions, e.g. a function for each stage (build, test, deploy etc.).\u003c/li\u003e\n\u003cli\u003eA single Dagger pipeline function that contains all the stages.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eDagger functions are relatively new and while they would in practice be more ideal to encapsulate and moduralize the pipeline, we will use the single Dagger pipeline function for the exercises. It is compact and simpler to maintain when workflows are small.\u003c/p\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\n\u003ch2\u003eTypical Dagger pipeline structure\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eA pipeline in Go in its simplest form is a single file, e.g. \u003ccode\u003epipeline.go\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eThe pipeline starts through the entry point function \u003ccode\u003emain()\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eA Dagger client and background context is created. This is what orchestrates Docker under the hood and is responsible for building the execution graph.\u003c/li\u003e\n\u003cli\u003ePipeline stages are defined. These consist of the code you want to run, e.g. shell commands.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\n\u003cp\u003e\u003cimg src=\"https://media1.tenor.com/m/4EYaYAMus0cAAAAd/michael-scott-the-office.gif\" alt=\"Show me more\"\u003e\u003c/p\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\n\u003ch2\u003eHow it works\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"../../images/lessons/dagger/dagger-oci.png\" alt=\"Dagger how it works with OCI\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSource: \u003ca href=\"https://archive.docs.dagger.io/0.9/sdk/go/\"\u003ehttps://archive.docs.dagger.io/0.9/sdk/go/\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/br\u003e\n\n\u003cp\u003eWhen you run a Dagger pipeline using the Go SDK, the following happens:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eClient initialization\u003c/strong\u003e: Your Go program imports the Dagger Go SDK and creates a client connection by calling \u003ccode\u003edagger.Connect(ctx)\u003c/code\u003e. The SDK handles all the GraphQL translation internally—you don\u0026#39;t need to know GraphQL.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eEngine provisioning\u003c/strong\u003e: The client either connects to an existing Dagger Engine or automatically provisions a new one on-the-fly. The Engine runs as an OCI-compatible (Open Container Initiative) container and acts as the runtime for your pipeline.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eSession creation\u003c/strong\u003e: Once connected, your client opens a session with the Engine. Each session gets its own GraphQL server instance that manages the API requests for that session.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003ePipeline definition\u003c/strong\u003e: Your Go code defines the pipeline operations (like creating containers, mounting directories, executing commands) using the SDK\u0026#39;s type-safe API. These operations are translated into GraphQL queries that describe your workflow.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eLazy evaluation\u003c/strong\u003e: The Engine uses lazy evaluation—operations are only executed when their results are actually needed. For example, if you define a container build but never request its output, the build won\u0026#39;t run. This allows the Engine to optimize away unnecessary work.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eDAG computation\u003c/strong\u003e: When a result is requested (a \u0026quot;leaf value\u0026quot; like \u003ccode\u003estdout\u003c/code\u003e or exported files), the Engine computes a Directed Acyclic Graph (DAG) of all operations needed to produce that result. This graph represents the execution plan.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eConcurrent execution\u003c/strong\u003e: The Engine executes operations in the DAG concurrently wherever possible, maximizing parallelism and performance while respecting dependencies between operations.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eResult delivery\u003c/strong\u003e: Once all required operations complete, the Engine returns the results to your Go program. These results can be used as inputs to subsequent pipeline stages or exported to your local filesystem.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/br\u003e\n\n\u003cp\u003e\u003cem\u003eSource: \u003ca href=\"https://docs.dagger.io/manuals/developer/architecture/\"\u003ehttps://docs.dagger.io/manuals/developer/architecture/\u003c/a\u003e and \u003ca href=\"https://docs.dagger.io/api/internals/\"\u003ehttps://docs.dagger.io/api/internals/\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\n\u003cp\u003eOk.. Let\u0026#39;s continue and start building a pipeline! \u003ci class=\"fa-solid fa-rocket\"\u003e\u003c/i\u003e\u003c/p\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n","markdown":"\n## Before we dive in\n\nWe will be using Go for the example pipeline definition.\n\nThere are currently two ways to define a Dagger pipeline:\n\n1. Dagger functions, e.g. a function for each stage (build, test, deploy etc.).\n2. A single Dagger pipeline function that contains all the stages.\n\nDagger functions are relatively new and while they would in practice be more ideal to encapsulate and moduralize the pipeline, we will use the single Dagger pipeline function for the exercises. It is compact and simpler to maintain when workflows are small.\n\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\n## Typical Dagger pipeline structure\n\n1. A pipeline in Go in its simplest form is a single file, e.g. `pipeline.go`.\n2. The pipeline starts through the entry point function `main()`.\n3. A Dagger client and background context is created. This is what orchestrates Docker under the hood and is responsible for building the execution graph.\n4. Pipeline stages are defined. These consist of the code you want to run, e.g. shell commands.\n\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\n![Show me more](https://media1.tenor.com/m/4EYaYAMus0cAAAAd/michael-scott-the-office.gif)\n\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\u003c/br\u003e\n\n## How it works\n\n![Dagger how it works with OCI](../../images/lessons/dagger/dagger-oci.png)\n\n*Source: https://archive.docs.dagger.io/0.9/sdk/go/*\n\n\u003c/br\u003e\n\nWhen you run a Dagger pipeline using the Go SDK, the following happens:\n\n1. **Client initialization**: Your Go program imports the Dagger Go SDK and creates a client connection by calling `dagger.Connect(ctx)`. The SDK handles all the GraphQL translation internally—you don't need to know GraphQL.\n\n2. **Engine provisioning**: The client either connects to an existing Dagger Engine or automatically provisions a new one on-the-fly. The Engine runs as an OCI-compatible (Open Container Initiative) container and acts as the runtime for your pipeline.\n\n3. **Session creation**: Once connected, your client opens a session with the Engine. Each session gets its own GraphQL server instance that manages the API requests for that session.\n\n4. **Pipeline definition**: Your Go code defines the pipeline operations (like creating containers, mounting directories, executing commands) using the SDK's type-safe API. These operations are translated into GraphQL queries that describe your workflow.\n\n5. **Lazy evaluation**: The Engine uses lazy evaluation—operations are only executed when their results are actually needed. For example, if you define a container build but never request its output, the build won't run. This allows the Engine to optimize away unnecessary work.\n\n6. **DAG computation**: When a result is requested (a \"leaf value\" like `stdout` or exported files), the Engine computes a Directed Acyclic Graph (DAG) of all operations needed to produce that result. This graph represents the execution plan.\n\n7. **Concurrent execution**: The Engine executes operations in the DAG concurrently wherever possible, maximizing parallelism and performance while respecting dependencies between operations.\n\n8. **Result delivery**: Once all required operations complete, the Engine returns the results to your Go program. These results can be used as inputs to subsequent pipeline stages or exported to your local filesystem.\n\n\u003c/br\u003e\n\n*Source: https://docs.dagger.io/manuals/developer/architecture/ and https://docs.dagger.io/api/internals/*\n\n\u003c/br\u003e\n\u003c/br\u003e\n\nOk.. Let's continue and start building a pipeline! \u003ci class=\"fa-solid fa-rocket\"\u003e\u003c/i\u003e\n\n\u003c/br\u003e\n\u003c/br\u003e\n","slug":"typical-structure","title":"Typical Dagger pipeline structure","section":"Introducing Dagger","icon":"code","filePath":"/home/runner/work/itu-bds-sdse/itu-bds-sdse/lessons/09-workflows-introducing-dagger/E-typical-structure.md","nextSlug":"/itu-bds-sdse/lessons/workflows-creating-and-running-a-dagger-pipeline/new-dagger-pipeline","prevSlug":"/itu-bds-sdse/lessons/workflows-introducing-dagger/common-scenario-and-benefits"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"workflows-introducing-dagger","slug":"typical-structure"},"buildId":"aGU_TgP1G33XsxgAaS_TT","assetPrefix":"/itu-bds-sdse","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>