{"pageProps":{"post":{"attributes":{"description":"Basics of Git.","title":"Interactive rebasing and squashing","keywords":["Software engineering","Git"]},"html":"<h2>Interactive rebasing and squashing</h2>\n<p>Sometimes we want to <em><strong>squash</strong></em> multiple commits into one. </p>\n<p>Maybe we did a lot of small commits with poor messages while working on a feature. Maybe we want to push a single commit containing all the changes for the feature—making it easy to revert later on, if needed.</p>\n<p>In practice this is done with interactive rebasing.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>Essentially squashing takes this.</p>\n</br>\n\n<p><img src=\"../../images/lessons/git/squash-before.svg\" alt=\"Squashing before\"></p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>And turns it into this.</p>\n<p><img src=\"../../images/lessons/git/squash-after.svg\" alt=\"Squashing after\"></p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>Interactive rebasing allows squashing commits but also allows us to edit commit messages, reorder commits, and even remove commits.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h3>Exercise: Squashing commits - set the stage</h3>\n<p>We need to set the stage first by creating some commits.</p>\n<blockquote>\n<ul>\n<li>Navigate to the <code>remote-git</code> repository.</li>\n<li>Checkout the <code>feature</code> branch.</li>\n<li>Append <strong>3 changes</strong> to the <code>README.md</code> file and commit each change with a unique message.</li>\n</ul>\n</blockquote>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h3>Solution: Squashing commits - set the stage</h3>\n<p>Navigate to the <code>remote-git</code> repository.</p>\n<pre><code class=\"hljs language-bash\">git checkout feature\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Change 1&quot;</span> &gt;&gt; README.md\ngit add README.md\ngit commit -m <span class=\"hljs-string\">&quot;Change 1&quot;</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Change 2&quot;</span> &gt;&gt; README.md\ngit add README.md\ngit commit -m <span class=\"hljs-string\">&quot;Change 2&quot;</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Change 3&quot;</span> &gt;&gt; README.md\ngit add README.md\ngit commit -m <span class=\"hljs-string\">&quot;Change 3&quot;</span>\n</code></pre></br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h2>Interactive rebase steps</h2>\n<p>To begin, we need to provide a point in time to rebase with. The simplest way to do this is typically with <code>HEAD~n</code>, where <code>n</code> is the number of commits back we want to go. This format is also called a <em><strong>commit-ish</strong></em>.</p>\n<p>So, <code>HEAD~1</code> means one commit back from <code>HEAD</code>.</p>\n</br>\n</br>\n\n<p>The command for interactive rebase is:</p>\n<pre><code class=\"hljs language-bash\">git rebase -i &lt;commit-ish&gt;\n</code></pre></br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h3>Exercise: Squashing commits - interactive rebase</h3>\n<p>Now we will squash the commits.</p>\n<p>We want all the 3 latest changes to be a single commit and update the commit message.</p>\n<blockquote>\n<ul>\n<li>Start an interactive rebase with the last 3 commits.</li>\n</ul>\n</blockquote>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h3>Solution: Squashing commits - interactive rebase</h3>\n<pre><code class=\"hljs language-bash\">git rebase -i HEAD~3\n</code></pre></br>\n\n<p><strong>Output:</strong></p>\n<pre><code class=\"hljs language-plaintext\">pick a4ebcc2 Change 1\npick 04b43c8 Change 2\npick 8406816 Change 3\n\n# Rebase 7142285..8406816 onto 7142285 (3 commands)\n#\n# Commands:\n# p, pick &lt;commit&gt; = use commit\n# r, reword &lt;commit&gt; = use commit, but edit the commit message\n# e, edit &lt;commit&gt; = use commit, but stop for amending\n# s, squash &lt;commit&gt; = use commit, but meld into previous commit\n# f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous\n#                    commit&#x27;s log message, unless -C is used, in which case\n#                    keep only this commit&#x27;s message; -c is same as -C but\n#                    opens the editor\n# x, exec &lt;command&gt; = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)\n# d, drop &lt;commit&gt; = remove commit\n# l, label &lt;label&gt; = label current HEAD with a name\n# t, reset &lt;label&gt; = reset HEAD to a label\n# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]\n#         create a merge commit using the original merge commit&#x27;s\n#         message (or the oneline, if no original merge commit was\n#         specified); use -c &lt;commit&gt; to reword the commit message\n# u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated\n#                       to this position in the new commits. The &lt;ref&gt; is\n#                       updated at the end of the rebase\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n</code></pre></br>\n\n<p>To squash the commits, we need to change the <code>pick</code> command to <code>squash</code> or <code>s</code> for the commits we want to squash.</p>\n</br>\n\n<pre><code class=\"hljs language-plaintext\">pick a4ebcc2 Change 1\ns 04b43c8 Change 2\ns 8406816 Change 3\n</code></pre><p>And we save with <code>:wq</code> and <code>Enter</code>.</p>\n</br>\n</br>\n\n<p>This brings up the editor to edit the commit message.</p>\n<p><strong>Output:</strong></p>\n<pre><code class=\"hljs language-plaintext\"># This is a combination of 3 commits.\n# This is the 1st commit message:\n\nChange 1\n\n# This is the commit message #2:\n\nChange 2\n\n# This is the commit message #3:\n\nChange 3\n\n# Please enter the commit message for your changes. Lines starting\n# with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.\n#\n# Date:      Wed Sep 25 00:24:11 2024 +0200\n#\n# interactive rebase in progress; onto 7142285\n# Last commands done (3 commands done):\n#    squash 04b43c8 Change 2\n#    squash 8406816 Change 3\n# No commands remaining.\n# You are currently rebasing branch &#x27;main&#x27; on &#x27;7142285&#x27;.\n#\n# Changes to be committed:\n#       modified:   README.md\n#\n~\n~\n~\n</code></pre></br>\n</br>\n\n<p>We edit the commit message to something like <code>Feature X</code>.</p>\n<p><strong>Output:</strong></p>\n<pre><code class=\"hljs language-plaintext\"># This is a combination of 3 commits.\n# This is the 1st commit message:\n\nFeature X\n\n# Please enter the commit message for your changes. Lines starting\n# with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.\n#\n# Date:      Wed Sep 25 00:24:11 2024 +0200\n#\n# interactive rebase in progress; onto 7142285\n# Last commands done (3 commands done):\n#    squash 04b43c8 Change 2\n#    squash 8406816 Change 3\n# No commands remaining.\n# You are currently rebasing branch &#x27;main&#x27; on &#x27;7142285&#x27;.\n#\n# Changes to be committed:\n#       modified:   README.md\n#\n~\n~\n~\n</code></pre><p>And again we save with <code>:wq</code> and <code>Enter</code>.</p>\n</br>\n\n<p><strong>Output:</strong></p>\n<pre><code class=\"hljs language-plaintext\">[detached HEAD e3f045e] Feature X\n Date: Wed Sep 25 00:24:11 2024 +0200\n 1 file changed, 3 insertions(+)\nSuccessfully rebased and updated refs/heads/main.\n</code></pre></br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>Check the log to see the changes.</p>\n<pre><code class=\"hljs language-bash\">git <span class=\"hljs-built_in\">log</span> --oneline --graph\n</code></pre></br>\n\n<p>We will see that the 3 commits have been squashed into one with the message <code>Feature X</code>.</p>\n<p><strong>Output:</strong></p>\n<pre><code class=\"hljs language-plaintext\">* e3f045e (HEAD -&gt; main) Feature X\n</code></pre></br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>When we push to the remote respository, and in some cases you may need to do <code>git push --force</code> to overwrite the remote branch.</p>\n<p>Know that it exists. Use <code>--force</code> with caution.</p>\n</br>\n</br>\n","markdown":"\n## Interactive rebasing and squashing\n\nSometimes we want to ***squash*** multiple commits into one. \n\nMaybe we did a lot of small commits with poor messages while working on a feature. Maybe we want to push a single commit containing all the changes for the feature—making it easy to revert later on, if needed.\n\nIn practice this is done with interactive rebasing.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nEssentially squashing takes this.\n\n</br>\n\n![Squashing before](../../images/lessons/git/squash-before.svg)\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nAnd turns it into this.\n\n![Squashing after](../../images/lessons/git/squash-after.svg)\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nInteractive rebasing allows squashing commits but also allows us to edit commit messages, reorder commits, and even remove commits.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n### Exercise: Squashing commits - set the stage\n\nWe need to set the stage first by creating some commits.\n\n> * Navigate to the `remote-git` repository.\n> * Checkout the `feature` branch.\n> * Append **3 changes** to the `README.md` file and commit each change with a unique message.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n### Solution: Squashing commits - set the stage\n\nNavigate to the `remote-git` repository.\n\n```bash\ngit checkout feature\necho \"Change 1\" >> README.md\ngit add README.md\ngit commit -m \"Change 1\"\necho \"Change 2\" >> README.md\ngit add README.md\ngit commit -m \"Change 2\"\necho \"Change 3\" >> README.md\ngit add README.md\ngit commit -m \"Change 3\"\n```\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n## Interactive rebase steps\n\nTo begin, we need to provide a point in time to rebase with. The simplest way to do this is typically with `HEAD~n`, where `n` is the number of commits back we want to go. This format is also called a ***commit-ish***.\n\nSo, `HEAD~1` means one commit back from `HEAD`.\n\n</br>\n</br>\n\nThe command for interactive rebase is:\n\n```bash\ngit rebase -i <commit-ish>\n```\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n### Exercise: Squashing commits - interactive rebase\n\nNow we will squash the commits.\n\nWe want all the 3 latest changes to be a single commit and update the commit message.\n\n> * Start an interactive rebase with the last 3 commits.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n### Solution: Squashing commits - interactive rebase\n\n```bash\ngit rebase -i HEAD~3\n```\n\n</br>\n\n**Output:**\n\n```plaintext\npick a4ebcc2 Change 1\npick 04b43c8 Change 2\npick 8406816 Change 3\n\n# Rebase 7142285..8406816 onto 7142285 (3 commands)\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup [-C | -c] <commit> = like \"squash\" but keep only the previous\n#                    commit's log message, unless -C is used, in which case\n#                    keep only this commit's message; -c is same as -C but\n#                    opens the editor\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n#         create a merge commit using the original merge commit's\n#         message (or the oneline, if no original merge commit was\n#         specified); use -c <commit> to reword the commit message\n# u, update-ref <ref> = track a placeholder for the <ref> to be updated\n#                       to this position in the new commits. The <ref> is\n#                       updated at the end of the rebase\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n```\n\n</br>\n\nTo squash the commits, we need to change the `pick` command to `squash` or `s` for the commits we want to squash.\n\n</br>\n\n```plaintext\npick a4ebcc2 Change 1\ns 04b43c8 Change 2\ns 8406816 Change 3\n```\n\nAnd we save with `:wq` and `Enter`.\n\n</br>\n</br>\n\nThis brings up the editor to edit the commit message.\n\n**Output:**\n\n```plaintext\n# This is a combination of 3 commits.\n# This is the 1st commit message:\n\nChange 1\n\n# This is the commit message #2:\n\nChange 2\n\n# This is the commit message #3:\n\nChange 3\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# Date:      Wed Sep 25 00:24:11 2024 +0200\n#\n# interactive rebase in progress; onto 7142285\n# Last commands done (3 commands done):\n#    squash 04b43c8 Change 2\n#    squash 8406816 Change 3\n# No commands remaining.\n# You are currently rebasing branch 'main' on '7142285'.\n#\n# Changes to be committed:\n#       modified:   README.md\n#\n~\n~\n~\n```\n\n</br>\n</br>\n\nWe edit the commit message to something like `Feature X`.\n\n**Output:**\n\n```plaintext\n# This is a combination of 3 commits.\n# This is the 1st commit message:\n\nFeature X\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# Date:      Wed Sep 25 00:24:11 2024 +0200\n#\n# interactive rebase in progress; onto 7142285\n# Last commands done (3 commands done):\n#    squash 04b43c8 Change 2\n#    squash 8406816 Change 3\n# No commands remaining.\n# You are currently rebasing branch 'main' on '7142285'.\n#\n# Changes to be committed:\n#       modified:   README.md\n#\n~\n~\n~\n```\n\nAnd again we save with `:wq` and `Enter`.\n\n</br>\n\n**Output:**\n\n```plaintext\n[detached HEAD e3f045e] Feature X\n Date: Wed Sep 25 00:24:11 2024 +0200\n 1 file changed, 3 insertions(+)\nSuccessfully rebased and updated refs/heads/main.\n```\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nCheck the log to see the changes.\n\n```bash\ngit log --oneline --graph\n```\n\n</br>\n\nWe will see that the 3 commits have been squashed into one with the message `Feature X`.\n\n**Output:**\n\n```plaintext\n* e3f045e (HEAD -> main) Feature X\n```\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nWhen we push to the remote respository, and in some cases you may need to do `git push --force` to overwrite the remote branch.\n\nKnow that it exists. Use `--force` with caution.\n\n</br>\n</br>\n","slug":"interactive-rebase-and-squashing","title":"Interactive rebasing and squashing","section":"Git basics","icon":"code","filePath":"/home/runner/work/itu-bds-sdse/itu-bds-sdse/lessons/06-git-basics/L-interactive-rebase-and-squashing.md","nextSlug":"/itu-bds-sdse/lessons/git-basics/searching-logs","prevSlug":"/itu-bds-sdse/lessons/git-basics/stashing-changes"}},"__N_SSG":true}