{"pageProps":{"post":{"attributes":{"description":"Fundamentals of the Go programming language.","title":"Channels","keywords":["Software engineering","Go"]},"html":"<h2>Channels</h2>\n<p>A common challenge when using threads is to coordinate the communication between them. Go provides a mechanism to solve this problem: <strong>channels</strong>.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<ul>\n<li><strong>goroutines</strong> can communicate with each other using <em>channels</em>, which is a special type of variable.</li>\n<li>A <strong>channel</strong> can contain a <em>value</em> of <em>any kind</em>.</li>\n<li>A <strong>goroutine</strong> can send a value to a <strong>channel</strong> and another <strong>goroutine</strong> can receive it.</li>\n<li>Channels can be <em>buffered</em> or <em>unbuffered</em>.</li>\n</ul>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h2>Using channels</h2>\n<h3>Unbuffered</h3>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> ch <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>\n\nch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>)\n\nch &lt;- <span class=\"hljs-string\">&quot;hello&quot;</span>\n\nmessage := &lt;-ch\n</code></pre></br>\n</br>\n\n<h3>Example</h3>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)\n    <span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n        ch &lt;- <span class=\"hljs-number\">42</span>\n    }()\n    fmt.Println(&lt;-ch)\n}\n</code></pre></br>\n\n<blockquote>\n<p>The <code>func()</code> here is an example of an <strong>anonymous function</strong>, or a <strong>lambda</strong>.</p>\n</blockquote>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h3>Buffered</h3>\n<p>We can also have buffered channels.</p>\n<p>In this case we specify the number of values that can be stored in the channel.</p>\n<pre><code class=\"hljs language-go\">ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">2</span>)\nch &lt;- <span class=\"hljs-string\">&quot;hello&quot;</span>\nch &lt;- <span class=\"hljs-string\">&quot;world&quot;</span>\n\nfmt.Println(&lt;-ch)\nfmt.Println(&lt;-ch)\n</code></pre><blockquote>\n<p>If you pull a message from the buffer, the thread will wait until a message is sent to the channel.</p>\n</blockquote>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h2>Things to be aware of</h2>\n<ul>\n<li><strong>Deadlocks</strong> can occur if a channel is not closed.</li>\n</ul>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-built_in\">close</span>(channel)\n</code></pre></br>\n\n<blockquote>\n<p><strong>Good practice:</strong> Use the <code>defer</code> keyword to close the channel and to keep code in related blocks.</p>\n</blockquote>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h2>Waitgroups</h2>\n<p>A <strong>waitgroup</strong> is a way to wait for a collection of goroutines to finish.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> wg sync.WaitGroup\n\nwg.Add(<span class=\"hljs-number\">1</span>)\n<span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">defer</span> wg.Done()\n    fmt.Println(<span class=\"hljs-string\">&quot;Hello&quot;</span>)\n}()\nwg.Wait()\n</code></pre></br>\n</br>\n","markdown":"\n## Channels\n\nA common challenge when using threads is to coordinate the communication between them. Go provides a mechanism to solve this problem: **channels**.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n* **goroutines** can communicate with each other using *channels*, which is a special type of variable.\n* A **channel** can contain a *value* of *any kind*.\n* A **goroutine** can send a value to a **channel** and another **goroutine** can receive it.\n* Channels can be *buffered* or *unbuffered*.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n## Using channels\n\n### Unbuffered\n\n```go\nvar ch chan string\n\nch := make(chan string)\n\nch <- \"hello\"\n\nmessage := <-ch\n```\n\n</br>\n</br>\n\n### Example\n\n```go\nfunc main() {\n    ch := make(chan int)\n    go func() {\n        ch <- 42\n    }()\n    fmt.Println(<-ch)\n}\n```\n\n</br>\n\n> The `func()` here is an example of an **anonymous function**, or a **lambda**.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n### Buffered\n\nWe can also have buffered channels.\n\nIn this case we specify the number of values that can be stored in the channel.\n\n```go\nch := make(chan string, 2)\nch <- \"hello\"\nch <- \"world\"\n\nfmt.Println(<-ch)\nfmt.Println(<-ch)\n```\n\n> If you pull a message from the buffer, the thread will wait until a message is sent to the channel.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n## Things to be aware of\n\n* **Deadlocks** can occur if a channel is not closed.\n\n```go\nclose(channel)\n```\n\n</br>\n\n> **Good practice:** Use the `defer` keyword to close the channel and to keep code in related blocks.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n## Waitgroups\n\nA **waitgroup** is a way to wait for a collection of goroutines to finish.\n\n```go\nvar wg sync.WaitGroup\n\nwg.Add(1)\ngo func() {\n    defer wg.Done()\n    fmt.Println(\"Hello\")\n}()\nwg.Wait()\n```\n\n</br>\n</br>\n","slug":"channels","title":"Channels","section":"Go fundamentals","icon":"code","filePath":"/home/runner/work/itu-bds-sdse/itu-bds-sdse/lessons/04-golang-fundamentals/S-channels.md","nextSlug":"/itu-bds-sdse/lessons/golang-fundamentals/testing","prevSlug":"/itu-bds-sdse/lessons/golang-fundamentals/goroutines"}},"__N_SSG":true}