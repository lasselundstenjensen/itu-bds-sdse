{"pageProps":{"post":{"attributes":{"description":"Fundamentals of the Go programming language.","title":"Interfaces","keywords":["Software engineering","Go"]},"html":"<h2>Interfaces</h2>\n<p>Interfaces are a way to define a set of methods that a type must implement.</p>\n<p>They are a powerful feature of Go, and they are used to define contracts between types.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h2>Why do we need interfaces?</h2>\n<p>Well, let&#39;s say we want to create an array of Courses and Workshops, so we can iterate and print them.</p>\n<p>We run into a problem.</p>\n</br>\n\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> courses [<span class=\"hljs-number\">2</span>]Course\ncourses[<span class=\"hljs-number\">0</span>] = goCourse\ncourses[<span class=\"hljs-number\">1</span>] = goWorkshop <span class=\"hljs-comment\">// error</span>\n\n<span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> courses {\n    fmt.Println(c)\n}\n</code></pre></br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>The same type problem occurs when we want to create a function that can receive both Courses and Workshops. Like for instance a function <code>SignUp()</code>.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>To get around this, we create an interface. Let&#39;s call it <code>Signable</code>.</p>\n</br>\n\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Signable <span class=\"hljs-keyword\">interface</span> {\n    SignUp() <span class=\"hljs-type\">string</span>\n}\n</code></pre></br>\n\n<p>Interfaces define a set of methods that a type must implement in order to fulfil the contract.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>This is how the <code>Course</code> and <code>Workshop</code> method implementations would look like:</p>\n</br>\n\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c Course)</span></span> SignUp() <span class=\"hljs-type\">string</span> {\n    <span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">&quot;Signed up for the course %s&quot;</span>, c.Name)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(w Workshop)</span></span> SignUp() <span class=\"hljs-type\">string</span> {\n    <span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">&quot;Signed up for the workshop %s&quot;</span>, w.Name)\n}\n</code></pre></br>\n\n<p>And this this would work, since both <code>Course</code> and <code>Workshop</code> implement the <code>Signable</code> interface:</p>\n</br>\n\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> courses [<span class=\"hljs-number\">2</span>]Signable\ncourses[<span class=\"hljs-number\">0</span>] = goCourse\ncourses[<span class=\"hljs-number\">1</span>] = goWorkshop\n\n<span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> courses {\n    fmt.Println(c)\n}\n</code></pre></br>\n\n<p>This may seem confusing, since we are not explicitly saying that <code>Course</code> and <code>Workshop</code> implement the <code>Signable</code> interface.</p>\n</br>\n\n<blockquote>\n<p>In Go, implementation is <strong>implicit</strong>. If a type has the methods defined in the interface, it implements the interface.</p>\n</blockquote>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>What we have just done is also known as polymorphism.</p>\n</br>\n</br>\n","markdown":"\n## Interfaces\n\nInterfaces are a way to define a set of methods that a type must implement.\n\nThey are a powerful feature of Go, and they are used to define contracts between types.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n## Why do we need interfaces?\n\nWell, let's say we want to create an array of Courses and Workshops, so we can iterate and print them.\n\nWe run into a problem.\n\n</br>\n\n```go\nvar courses [2]Course\ncourses[0] = goCourse\ncourses[1] = goWorkshop // error\n\nfor _, c := range courses {\n    fmt.Println(c)\n}\n```\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nThe same type problem occurs when we want to create a function that can receive both Courses and Workshops. Like for instance a function `SignUp()`.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nTo get around this, we create an interface. Let's call it `Signable`.\n\n</br>\n\n```go\ntype Signable interface {\n    SignUp() string\n}\n```\n\n</br>\n\nInterfaces define a set of methods that a type must implement in order to fulfil the contract.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nThis is how the `Course` and `Workshop` method implementations would look like:\n\n</br>\n\n```go\nfunc (c Course) SignUp() string {\n    return fmt.Sprintf(\"Signed up for the course %s\", c.Name)\n}\n\nfunc (w Workshop) SignUp() string {\n    return fmt.Sprintf(\"Signed up for the workshop %s\", w.Name)\n}\n```\n\n</br>\n\nAnd this this would work, since both `Course` and `Workshop` implement the `Signable` interface:\n\n</br>\n\n```go\nvar courses [2]Signable\ncourses[0] = goCourse\ncourses[1] = goWorkshop\n\nfor _, c := range courses {\n    fmt.Println(c)\n}\n```\n\n</br>\n\nThis may seem confusing, since we are not explicitly saying that `Course` and `Workshop` implement the `Signable` interface.\n\n</br>\n\n> In Go, implementation is **implicit**. If a type has the methods defined in the interface, it implements the interface.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nWhat we have just done is also known as polymorphism.\n\n</br>\n</br>\n","slug":"defining-interfaces","title":"Interfaces","section":"Go fundamentals","icon":"code","filePath":"/home/runner/work/itu-bds-sdse/itu-bds-sdse/lessons/04-golang-fundamentals/Q-defining-interfaces.md","nextSlug":"/itu-bds-sdse/lessons/golang-fundamentals/goroutines","prevSlug":"/itu-bds-sdse/lessons/golang-fundamentals/struct-embedding"}},"__N_SSG":true}