{"pageProps":{"post":{"attributes":{"description":"Fundamentals of the Go programming language.","title":"panic, defer, recover, and error handling","keywords":["Software engineering","Go"]},"html":"<h1>Special functions</h1>\n<ul>\n<li>Package <strong>init</strong> func</li>\n<li><strong>panic</strong></li>\n<li><strong>defer</strong></li>\n<li><strong>recover</strong></li>\n</ul>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h2>init</h2>\n<p>Used to run code that runs before the main function. </p>\n<p>All init functions across all packages are executed.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h2>panic</h2>\n<p>This is an interruption. It will terminate the program, if not handled.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h2>defer</h2>\n<p>It defers the execution of &quot;something&quot; until the end of the function.</p>\n<p>Last in, first out.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>It works with <code>panic()</code> and <code>recover()</code>.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h2>recover</h2>\n<p>It is used to recover from a panic.</p>\n</br>\n\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n        <span class=\"hljs-keyword\">if</span> r := <span class=\"hljs-built_in\">recover</span>(); r != <span class=\"hljs-literal\">nil</span> {\n            fmt.Println(<span class=\"hljs-string\">&quot;Recovered from panic:&quot;</span>, r)\n        }\n    }()\n\n    functionThatCanPanic()\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">functionThatCanPanic</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-built_in\">panic</span>(<span class=\"hljs-string\">&quot;A problem happened!&quot;</span>)\n}\n</code></pre><p><strong>Output:</strong></p>\n<pre><code class=\"hljs language-text\">Recovered from panic: A problem happened!\n</code></pre></br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<h2>Error handling</h2>\n<p>We do not have exceptions in Go.</p>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n<p>This is the typical design pattern when dealing with errors (~kind of pseudocode):</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">readFile</span><span class=\"hljs-params\">(file <span class=\"hljs-type\">string</span>)</span></span> (<span class=\"hljs-type\">string</span>, err) {\n    <span class=\"hljs-comment\">// attempt to read the file and set the &#x27;ok&#x27; boolean</span>\n    <span class=\"hljs-keyword\">if</span> ok {\n        <span class=\"hljs-keyword\">return</span> data, <span class=\"hljs-literal\">nil</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, errorDetails\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    data, err := readFile(<span class=\"hljs-string\">&quot;file.txt&quot;</span>)\n}\n</code></pre></br>\n</br>\n","markdown":"\n# Special functions\n\n- Package **init** func\n- **panic**\n- **defer**\n- **recover**\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n## init\n\nUsed to run code that runs before the main function. \n\nAll init functions across all packages are executed.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n## panic\n\nThis is an interruption. It will terminate the program, if not handled.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n## defer\n\nIt defers the execution of \"something\" until the end of the function.\n\nLast in, first out.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nIt works with `panic()` and `recover()`.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n## recover\n\nIt is used to recover from a panic.\n\n</br>\n\n```go\nfunc main() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"Recovered from panic:\", r)\n        }\n    }()\n\n    functionThatCanPanic()\n}\n\nfunc functionThatCanPanic() {\n    panic(\"A problem happened!\")\n}\n```\n\n**Output:**\n\n```text\nRecovered from panic: A problem happened!\n```\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n## Error handling\n\nWe do not have exceptions in Go.\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\nThis is the typical design pattern when dealing with errors (~kind of pseudocode):\n\n```go\nfunc readFile(file string) (string, err) {\n    // attempt to read the file and set the 'ok' boolean\n    if ok {\n        return data, nil\n    } else {\n        return \"\", errorDetails\n    }\n}\n\nfunc main() {\n    data, err := readFile(\"file.txt\")\n}\n```\n\n</br>\n</br>\n","slug":"panic-defer-recover-error-handling","title":"panic, defer, recover, and error handling","section":"Go fundamentals","icon":"code","filePath":"/home/runner/work/itu-bds-sdse/itu-bds-sdse/lessons/04-golang-fundamentals/I-panic-defer-recover-error-handling.md","nextSlug":"/itu-bds-sdse/lessons/golang-fundamentals/control-structures","prevSlug":"/itu-bds-sdse/lessons/golang-fundamentals/pointers-and-references"}},"__N_SSG":true}